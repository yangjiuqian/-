# 基本概念

排序方法的分类：

+ 按数据存储介质: 内部排序和外部排序
+ 按比较器个数:串行排序和并行排序
+ 按主要操作:比较排序和基数排序
+ 按辅助空间:原地排序和非原地排序
+ 按稳定性:稳定排序和非稳定排序
+ 按自然性:自然排序和非自然排序

## 按数据存储介质*
+ **内部排序***: 数据量不大、数据在内存，无需内外存交换数据
+ **外部排序**:数据量较大、数据在外存(文件排序)；外部排序时，要将数据分批调入内存来排序，中间结果还要及时放入外存，显然外部排序要复杂得多

## 按比较器个数*
+ **串行排序***： 单处理机（同一时刻比较一对元素）
+ **并行排序**: 多处理机（同一时刻比较多对元素）

## 按主要操作可分为**
+ **比较排序**: 用比较的方法：插入排序、交换排序、选择排序、归并排序
+ **基数排序**:不比较元素的大小，仅仅根据元素本身的取值确定其有序位置

## 按辅助空间可分为
+ **原地排序**: 辅助空间用量为O(1)的排序方法(所占的辅助存储空间与参加排序的数据量大小无关)
+ **非原地排序**.辅助空间用量超过O（1）的排序方法

## 按稳定性可分为:
+ **稳定排序**:能够使任何数值相等的元素，排序以后相对次序不变
+ **非稳定性排序**:不是稳定排序的方法

## 按自然性可分为
+ **自然排序**:输入数据越有序，排序的速度越快的排序方法
+ **非自然排序**: 不是自然排序的方法

## 按排序依据原则
+ 插入排序:直接插入排序、折半插入排序、希尔排序
+ 交换排序:冒泡排序、快速排序
+ 选择排序:简单选择排序、堆排序
+ 归并排序:2-路归并排序
+ 基数排序

# 插入排序
    基本思想：每步将一个待排序的对象，按其关键码大小，插入到前面已经排好序的一组对象的适当位置上，直到对象全部插入为止。

    即边插入边排序，保证子序列中随时都是排好序的

**基本操作**：
+ 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。
+ 起初，a[0]是长度为1的子序列。然后逐一将a[1]至a[n-1]插入到有序子序列中

**分三类**：
+ 顺序法定位插入位置——直接插入排序
+ 二分法定位插入位置——二分插入排序
+ 缩小增量多遍插入排序——希尔排序

## 直接插入排序

基本操作：
+ 比较序列中两个关键字的大小
+ 移动记录

**性能分析**：  
**最好情况**：11，22，32，47，56，70，81，92，96
+ 比较次数为n-1
+ 移动次数0

**最坏情况**：85 92 96 81 70 56 47 32 25 11（逆有序）
+ 比较次数：
  $$\displaystyle\sum_{i=2}^{n}i=\frac {(n+2)(n-1)}{2}$$
+ 移动次数
   $$\displaystyle\sum_{i=2}^{n}(i+1)=\frac {(n+4)(n-1)}{2}$$
**平均情况**：  
+ 比较次数
    $$\displaystyle\sum_{i=1}^{n-1}\frac{i+1}{2}=\frac {1}{4}(n+2)(n-1)$$
+ 移动次数
  $$\displaystyle\sum_{i=1}^{n-1}（\frac{i+1}{2}+1）=\frac {1}{4}(n+6)(n-1)$$

:point_right: 原始数据越接近有序，排序速度越快  
:point_right: 最坏情况下(输入数据是逆有序的)Tw(n)=O(n<sup>2</sup>)  
:point_right: 平均情况下，耗时差不多是最坏情况的一半Te(n)=O(n<sup>2</sup>)  
:point_right: 要提高查找速度  
+ 减少元素的比较次数
+ 减少元素的移动次数
+ 
```
void directinser(int target[], int n){
    int x,j;
    //sizeof(target)×
    //无法直接sizeof（target），因为此处的target为指向一个数组的指针，不是一个数组
    //void directinser(int *target, int n)同样正确
    for(int i=1;i<n;i++){
        x=target[i];
        for(j=i-1;j>=0&&x<target[j];j--){
            target[j+1]=target[j];
        }
        target[j+1]=x;
    }
}

void directinser_withsentry(int target[], int n){
    int x,j;
    //sizeof(target)×
    //无法直接sizeof（target），因为此处的target为指向一个数组的指针，不是一个数组
    //void directinser(int *target, int n)同样正确
    for(int i=1;i<n;i++){
        target[0]=target[i];
        for(j=i-1;target[0]<target[j];j--){
            target[j+1]=target[j];
        }
        target[j+1]=target[0];
    }
}```