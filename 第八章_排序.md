# 基本概念

排序方法的分类：

+ 按数据存储介质: 内部排序和外部排序
+ 按比较器个数:串行排序和并行排序
+ 按主要操作:比较排序和基数排序
+ 按辅助空间:原地排序和非原地排序
+ 按稳定性:稳定排序和非稳定排序
+ 按自然性:自然排序和非自然排序

## 按数据存储介质*
+ **内部排序***: 数据量不大、数据在内存，无需内外存交换数据
+ **外部排序**:数据量较大、数据在外存(文件排序)；外部排序时，要将数据分批调入内存来排序，中间结果还要及时放入外存，显然外部排序要复杂得多

## 按比较器个数*
+ **串行排序***： 单处理机（同一时刻比较一对元素）
+ **并行排序**: 多处理机（同一时刻比较多对元素）

## 按主要操作可分为**
+ **比较排序**: 用比较的方法：插入排序、交换排序、选择排序、归并排序
+ **基数排序**:不比较元素的大小，仅仅根据元素本身的取值确定其有序位置

## 按辅助空间可分为
+ **原地排序**: 辅助空间用量为O(1)的排序方法(所占的辅助存储空间与参加排序的数据量大小无关)
+ **非原地排序**.辅助空间用量超过O（1）的排序方法

## 按稳定性可分为:
+ **稳定排序**:能够使任何数值相等的元素，排序以后相对次序不变
+ **非稳定性排序**:不是稳定排序的方法

## 按自然性可分为
+ **自然排序**:输入数据越有序，排序的速度越快的排序方法
+ **非自然排序**: 不是自然排序的方法

## 按排序依据原则
+ 插入排序:直接插入排序、折半插入排序、希尔排序
+ 交换排序:冒泡排序、快速排序
+ 选择排序:简单选择排序、堆排序
+ 归并排序:2-路归并排序
+ 基数排序

# 插入排序
    基本思想：每步将一个待排序的对象，按其关键码大小，插入到前面已经排好序的一组对象的适当位置上，直到对象全部插入为止。

    即边插入边排序，保证子序列中随时都是排好序的

**基本操作**：
+ 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。
+ 起初，a[0]是长度为1的子序列。然后逐一将a[1]至a[n-1]插入到有序子序列中

**分三类**：
+ 顺序法定位插入位置——直接插入排序
+ 二分法定位插入位置——二分插入排序
+ 缩小增量多遍插入排序——希尔排序

## 直接插入排序

基本操作：
+ 比较序列中两个关键字的大小
+ 移动记录

**性能分析**：  
**最好情况**：11，22，32，47，56，70，81，92，96
+ 比较次数为n-1
+ 移动次数0

**最坏情况**：85 92 96 81 70 56 47 32 25 11（逆有序）
+ 比较次数：
  $$\displaystyle\sum_{i=2}^{n}i=\frac {(n+2)(n-1)}{2}$$
+ 移动次数
   $$\displaystyle\sum_{i=2}^{n}(i+1)=\frac {(n+4)(n-1)}{2}$$
**平均情况**：  
+ 比较次数
    $$\displaystyle\sum_{i=1}^{n-1}\frac{i+1}{2}=\frac {1}{4}(n+2)(n-1)$$
+ 移动次数
  $$\displaystyle\sum_{i=1}^{n-1}（\frac{i+1}{2}+1）=\frac {1}{4}(n+6)(n-1)$$

:point_right: 原始数据越接近有序，排序速度越快  
:point_right: 最坏情况下(输入数据是逆有序的)Tw(n)=O(n<sup>2</sup>)  
:point_right: 平均情况下，耗时差不多是最坏情况的一半Te(n)=O(n<sup>2</sup>)  
:point_right: 要提高查找速度  
+ 减少元素的比较次数
+ 减少元素的移动次数
+ 
```
void directinser(int target[], int n){
    int x,j;
    //sizeof(target)×
    //无法直接sizeof（target），因为此处的target为指向一个数组的指针，不是一个数组
    //void directinser(int *target, int n)同样正确
    for(int i=1;i<n;i++){
        x=target[i];
        for(j=i-1;j>=0&&x<target[j];j--){
            target[j+1]=target[j];
        }
        target[j+1]=x;
    }
}

void directinser_withsentry(int target[], int n){
    int x,j;
    //sizeof(target)×
    //无法直接sizeof（target），因为此处的target为指向一个数组的指针，不是一个数组
    //void directinser(int *target, int n)同样正确
    for(int i=1;i<n;i++){
        target[0]=target[i];
        for(j=i-1;target[0]<target[j];j--){
            target[j+1]=target[j];
        }
        target[j+1]=target[0];
    }
}
```

## 折半插入排序

```
void binaryInsertionSort(std::vector<int>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; ++i) {
        int key = arr[i];
        int low = 0, high = i - 1;

        // 使用二分查找找到插入位置
        while (low <= high) {
            int mid = (low + high) / 2;
            if (arr[mid] > key) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }

        // 移动元素以便插入
        for (int j = i - 1; j >= low; --j) {
            arr[j + 1] = arr[j];
        }

        // 插入元素到正确位置
        arr[low] = key;
    }
}

```

## 希尔排序

    基本思想： 先将整个待排记录序列分割成若开子序列，分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。

**思路**：
1. 定义增量序列$`D_k: D_M>D_{M-1}>...>D_1=1`$
2. 对每个D<sub>K</sub>进行“D<sub>K</sub>-间隔”插入排序 (k=M，M-1，...1)
   
**特点**：
+ 次移动，移动位置较大，
+ 跳跃式地接近排序后的最终位置
+ 最后一次只需要少量移动
+ 最后一个必须是1增量序列必须是递减的
+ 增量序列应该是互质的

```
#include<iostream>
#include<vector>

using namespace std;

void ShellInsert(vector<int>& targrt, int dk);

void ShellSort(vector<int>& target, int dlta[], int t);

int main(){
    vector<int> a={0,81,94,11,96,12,35,17,95,28,58,41,75,15};
    int dlda[3]={5,3,1};
    ShellSort(a,dlda,3);
    for(int r=1;r<a.size();r++){
        cout<<a[r]<<endl;
    }
    return 0;
}

void ShellSort(vector<int>& target, int dlta[], int t){
    for(int k=0;k<t;++k){
        ShellInsert(target,dlta[k]);
    }
}

void ShellInsert(vector<int>& t, int dk){
    int i,j;
    // int temp;
    for(i=dk+1;i<t.size();++i){
        t[0] = t[i];
        for(j=i-dk;j>0&&(t[0]<t[j]);j=j-dk){
            t[j+dk]=t[j];
        }
        t[j+dk]=t[0];
    }
}
```

+ 时间复杂度是n和d的函数：
  $$O(n^1.25)\text{到}O(1.6n^1.25)\text{经验公式}$$
+ 空间复杂度为 O(1)
+ :point_right: 希尔排序是一种不稳定的排序算法
  + 如何选择最佳d序列，目前尚未解决
  + 最后一个增量值必须为1，无除了1之外的公因子
  + 不宜在链式存储结构上实现


## 交换排序
