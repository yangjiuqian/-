# 图的定义和术语
+ 图：G=(V,E)  
V:顶点（数据元素）的有穷非空集合；  
E：边的集合；  
+ 无向图：每条边都是无方向的
+ 有向图：每条边都是有方向的
+ 完全图：任意两个点都有一条边相连；
+ 稀疏图：有很少边或弧的图（e<nlogn)
+ 稠密图:有较多边或弧的图
+ 网：边/弧带权的图"()"表示边“<>”表示弧
+ 邻接：有边/弧相连的两个顶点之间的关系；存在(v<sub>i</sub>, v<sub>j</sub>)，则称v<sub>i</sub>和 v<sub>j</sub>;互为邻接点;存在<v<sub>i</sub>,  v<sub>j</sub>>，则称v<sub>i</sub>念接到v v<sub>j</sub>,v<sub>j</sub>邻接于v<sub>i</sub>
+ 关联（依附）：边/弧与顶点之间的关系
+ 存在(v<sub>i</sub>, v<sub>j</sub>)/ <v<sub>i</sub>,  v<sub>j</sub>>， 则称该边/弧关联于v<sub>i</sub>和v<sub>j</sub>;
+ 顶点的度: 与该顶点相关联的边的数目，记为TD(v)
  - 在有向图中,顶点的度等于该顶点的入度与出度之和。
  - 顶点 v 的入度是以 v 为终点的有向边的条数记作ID(v)
  - 顶点 v 的出度是以 v 为始点的有向边的条数记作 OD(v)
+ 路径：接续的边构成的顶点序列
  - 路径长度：路径上边或弧的数目/权值之和
  - 回路(环): 第个顶点和最后一个顶点相同的路径
  - 简单路径:除路径起点和终点可以相同外，其余顶点均不相同的路径
  - 简单回路(简单环): 除路径起点和终点相同外，其余顶点均不相同的路径
+ 连通图 (强连通图)：在无 (有) 向图G=(V，{E})中，若对任何两个顶点 v、u都存在从v 到 u 的路径，则称G是连通图 (强连通图）、
+ 权和网：图中边或弧所具有的相关数称为权表明从一个顶点到另一个顶点的距离或耗费
+ 子图：设有两个图G=(V，{E}) 、G1= (V1，{E1}) ，若V1∈V，E1∈E则称 G1是G的子图
+ 连通分量（强连通分量）：无向图G 的极大连通子图称为G的连通分量
  - 极大连通子图意思是: 该子图是 G 连通子图，将G 的任何不在该子图中的顶点加入，子图不再连通
  - 有向图G 的极大强连通子图称为G的强连通分量
  - 极大强连通子图意思是: 该子图是G的强连通子图，将D的任何不在该子图中的顶点加入，子图不再是强连通的。
+ 极小连通子图:该子图是G 的连通子图，在该子图中删除任何一条边子图不再连通
+ 生成树:包含无向图G所有顶点的极小连通子图
+ 生成森林:对非连通图，由各个连通分量的生成树的集合
# 案例引入
# 图的类型定义
# 图的存储结构
+ 数组表示法
  - 图没有顺序存储结构但可以借助二维数组来表示元素间的关系
  - 邻接矩阵
+ 链式存储结构:
  - 邻接表
  - 邻接多重表
  - 十字链表
**重点介绍：邻接矩阵，邻接表**
## 邻接矩阵
建立一个顶点表(记录各个顶点信息)和一个邻接矩阵（表示各个顶点之间关系)。  
设图A=(V,E)有n个顶点，则顶点表Vexs[n]


|i|0|1|2|...|n-1|
| --- | --- | --- | --- | --- | ---  |
|Vexs[i]|v1 |v2|v3|...|vn|

图的邻接矩阵是一个二维数组 A.arcs[n][n]，定义为

$$A.arcs[i][j] =
  \begin{cases}
    1       & \quad \text{if } \langle i,j\rangle∈E \text{ or }(i,j)∈E\\
    0  & \quad \text{else}
  \end{cases}$$

**无向图的邻接矩阵表示方法**：  
![image](https://github.com/yangjiuqian/DataStructure/assets/112688628/b6d7cee5-8877-48a9-80c8-0279caebda1f)
+ 分析1:无向图的邻接矩阵是对称的
+ 分析2:顶点i的度=第i行(列)中1 的个数
+ 完全图的邻接矩阵中，对角元素为0，其余1.

无向图的创建：  
+ (1)输入总顶点数和总边数
+ (2)依次输入点的信息存入顶点表中
+ (3)初始化邻接矩阵，使每个权值初始化为0
+ (4)构造邻接矩阵，权值为1
  
```
class Graph {
private:
    int numVertices;
    vector<vector<int>> adjacencyMatrix;
    unordered_map<int, string> vertexTable;  // 顶点表，将顶点的标识映射到实际的顶点名称

public:
    // 构造函数，初始化图的顶点数、邻接矩阵和顶点表
    Graph(int vertices) : numVertices(vertices), adjacencyMatrix(vertices, vector<int>(vertices, 0)) {}

    // 添加顶点，将顶点标识映射到实际的顶点名称
    void addVertex(int id, const string& name) {
        vertexTable[id] = name;
    }

    // 添加边
    void addEdge(int src, int dest) {
        // 无向图，两个方向都要设置为1
        adjacencyMatrix[src][dest] = 1;
        adjacencyMatrix[dest][src] = 1;
    }

    // 打印邻接矩阵
    void printMatrix() {
        // 打印顶点表
        cout << "Vertex Table:" << endl;
        for (const auto& entry : vertexTable) {
            cout << entry.first << ": " << entry.second << endl;
        }

        // 打印邻接矩阵
        cout << "Adjacency Matrix:" << endl;
        for (int i = 0; i < numVertices; ++i) {
            for (int j = 0; j < numVertices; ++j) {
                cout << adjacencyMatrix[i][j] << " ";
            }
            cout << endl;
        }
    }
};
```

**有向图的邻接矩阵表示法**：  
![image](github图片/image-2.png)
+ 第i行含义:以结点v<sub>i</sub>为尾的弧(即出度边) ;
+ 第i列含义:以结点v<sub>i</sub>为头的弧(即入度边).
+ 分析1:有向图的邻接矩阵可能是不对称的。
+ 分析2: 顶点的出度=第i行元素之和  
            顶点的入度=第i列元素之和

有向图的构建时只为一个方向赋值```adjacencyMatrix[src][dest] = 1;```,其余操作与无向图一致。

**网（有权图）的邻接矩阵表示法**：   
定义为:

$$A.arcs[i][j] =
  \begin{cases}
    W_{ij}       & \quad \text{if } \langle i,j\rangle∈E \text{ or }(i,j)∈E\\
    \infty  & \quad \text{else}
  \end{cases}$$

![image](github图片/image-3.png)

无向图的创建：  
+ (1)输入总顶点数和总边数
+ (2)依次输入点的信息存入顶点表中
+ (3)初始化邻接矩阵，使每个权值初始化为极大值
+ (4)构造邻接矩阵，```adjacencyMatrix[src][dest] = w;adjacencyMatrix[dest][src] = w;```w为权值
  
有向图的创建：仅赋值```adjacencyMatrix[src][dest] = w;```

![image](github图片/image.png)

**优缺点**：  
优点:
+ 直观、简单、好理解
+ 方便检查任意一对顶点间是否存在边
+ 方便找任一顶点的所有“邻接点”(有边直接相连的顶点)
+ 方便计算任一顶点的“度”(从该点发出的边数为“出度”，指向该点的边数为“入度”)

缺点：
+ 不便于增加和删除顶点
+ 浪费空间-存稀疏图 (点很多而边很少)有大量无效元素
+ 浪费时间一统计稀疏图中一共有多少条边
## 邻接表
**顶点**：按编号顺序将顶点数据存储在一组一维数组中；  
**关联同一项的边**：用线性链表存储；
![image](github图片/chain.png)
**无向图**的邻接表：  
![image](github图片/NonDerication.png)
特点：  
+ 邻接表不唯一
+ 若无向图中有 n 个顶点、e条边，则其邻接表需 n 个头结点和2e 个表结点。适宜存储稀疏图。
+ 无向图中顶点v<sub>i</sub>的度为第 i个单链表中的结点数.

**有向图**的邻接表：  
![image](github图片/1.png)
特点：  
+ 顶点v<sub>i</sub>的出度为第i个单链表中的结点个数。
+ 顶点v<sub>i</sub>的入度为整个单链表中邻接点域值是i-1的结点个数
+ 找出度容易，找入度难  
  

**逆邻接表**：  
![image](github图片/2.png)
特点：  
+ 顶点v<sub>i</sub>的入度为第i个单链表中的结点个数。
+ 顶点v<sub>i</sub>的出度为整个单链表中邻接点域值是i-1的结点个数
+ 找入度容易，找出度难

**算法思想**：  
+ （1）输入总顶点数和总边数
+ （2）建立顶点表，依次输入点的信息存入顶点表中，使每个表头结点的指针域初始化为NULL
+ 创建邻接表依次输入每条边依附的两个顶点确定两个顶点的序号i和j，建立边结点将此边结点分别插入到v<sub>i</sub>和v<sub>j</sub>对应的两个边链表的头部

**特点**:  
+ 方便找任一顶点的所有“邻接点"
+ 节约稀疏图的空间。需要N个头指针+2E个结点 (每个结点至少2个域)
+ 方便计算任一顶点的“度”?
  - 对无向图:是的
  - 对有向图:只能计算“出度”；需要构造“逆邻接表”(存指自己的边）来方便计算“入度”
+ 不方便检查任意一对顶点间是否存在边
## 邻接矩阵和邻接表的关系
![image](github图片/image-4.png)
+ 1.联系:邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数。
+ 2.区别
  - 对于任一确定的无向图邻接矩阵是唯一的 （行列号与顶点编号一致），但邻接表不唯一(链接次序与顶点编号无关)
  - 邻接矩阵的空间复杂度为O(n<sup>2</sup>),而邻接表的空间复杂度为O+e)
+ 用途：邻接矩阵多用于稠密图；邻接表多用于稀疏图；
  
# 图的遍历
# 图的应用
# 案例分析与实现