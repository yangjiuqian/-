# 查找的概念
:raising_hand: 在哪里找？   
                     ——查找表

查找表是由同一类型的数据元素 (或记录) 构成的集合。由于“集合”中的数据元素之间存在着松散的关系，因此查找表是一种应用灵便的结构

:raising_hand: 什么查找？——
根据给定的某个值，在查找表中确定一个其关键字等于给定值
的数据元素或(记录)  
**关键字**：用来标识一个数据元素 (或记录)的某个数据项的值
+ **主关键字**：可唯一地标识一个记录的关键字是主关键字
+ **次关键字**：反之，用以识别若千记录的关键字是次关键字。

:raising_hand: 查找成功否？
+ 若查找表中存在这样一个记录，则称“查找成功”查找结果给出整个记录的信息，或指示该记录在查找表中的位置、
+ 否则称“查找不成功”，查找结果给出“空记录”或“空指针”

:raising_hand: 查找的目的？
1. 查询某个“特定的”数据元素是否在查找表中
2. 检索某个“特定的”数据元素的各种属性
3. 在查找表中插入一个数据元素
4. 删除查找表中的某个数据元素

:raising_hand: 查找表怎么分类？
+ 静态查找表
  - 仅作“查询”（检索）操作的查找表
+ 动态查找表
  - 作“插入”和“删除”操作的查找表作
  - 有时在查询之后，还需要将“查询”结果为“不在查找表中”的数据元素插入到查找表中;
  - 或者，从查找表中删除其“查询”结果为在查找表中”的数据元素，此类表为动态查找表

:raising_hand: 如何评价查找算法？

关键字的平均比较次数，也称**平均查找长度**ASL(AVerage Search Length)
$$ASL=\displaystyle\sum_{i=1}^{n} p_ic_i   （关键字比较次数的期望值）$$

+ n：记录的个数
+ p<sub>i</sub>:查找第i个记录的概率（通常认为p<sub>i</sub>=1/n）  
+ c<sub>i</sub>：找到第i个记录所需的比较次数
  
:raising_hand: 如何评价查找算法？

查找的方法取决于查找表的结构，即表中数据元素是依何种关系组织在一起的。
由于对查找表来说，在集合中查询或检索一个“特定的”数据元素时若无规律可循，只能对集合中的元素一一加以辨认直至找到为止。
而这样的“查询”或“检索”是任何计算机应用系统中使用频度都很高的操作，因此设法提高查找表的查找效率，是本章讨论问题的出发点
为提高查找效率一个办法就是在构造查找表时，在集合中的数据元素之间人为地加上某种确定的约束关系
研究查找表的各种组织方法及其查找过程的实施
# 线性表的查找
## 顺序查找
应用范围
+ 顺序表或线性链表表示的静态查找表
+ 表内元素之间无序

时间复杂度：O(n)  
空间复杂度：O（1）  
ASL(n)=（n+1）/2  

:point_right: 1、记录的查找概率不相等时如何提高查找效率?
+ 查找表存储记录原则一按查找概率高低存储
+ 1)查找概率越高，比较次数越少
+ 2)查找概率越低，比较次数较多

:point_right: 记录的查找概率无法测定时如何提高查找效率?
+ 方法按查找概率动态调整记录顺序
+ 1)在每个记录中设一不访问频度域
+ 2)始终保持记录按非递增有序的次序排列
+ 3)每次查找后均将刚查到的记录直接移至表头
  
**特点**：  
+ 优点: 算法简单，逻辑次序无要求，且不同存储结构均适用。
+ 缺点: ASL太长，时间效率太低
## 二分查找（折半查找，对分查找）
**有序表**

折半查找: 每次将待查记录所在区间缩小一半
+ 设表长为n，low、high和mid分别指向待查元素所在区间的上界下界和中点，key为给定的要查找的值:
+ 初始时，令low=1，high=n，mid=L(low+high)/2
+ 让k与mid指向的记录比较
    - 若keY==R[mid].key， 查找成功
    - 若key<R[mid].key，则 high=mid-1
    - 若key>R[mid].key，则 low=mid+1
+ 重复上述操作，直至low>high时查找失败

```#include <iostream>
#include <vector>

// 二分查找函数
int binarySearch(const std::vector<int>& arr, int target) {
    int left = 0;
    int right = arr.size() - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        // 检查中间元素是否是目标值
        if (arr[mid] == target) {
            return mid;  // 目标值找到，返回索引
        } else if (arr[mid] < target) {
            left = mid + 1;  // 目标值可能在右半部分
        } else {
            right = mid - 1;  // 目标值可能在左半部分
        }
    }

    return -1;  // 目标值不在数组中
}

int main() {
    // 测试二分查找
    std::vector<int> sortedArray = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int target = 6;

    int result = binarySearch(sortedArray, target);

    if (result != -1) {
        std::cout << "目标值 " << target << " 在数组中，索引为 " << result << std::endl;
    } else {
        std::cout << "目标值 " << target << " 不在数组中" << std::endl;
    }

    return 0;
}
```
**判定树**： ![image](github图片/7-1.png)  
:point_right: ASL（成功时）： 
设表长 n = 2<sup>h</sup>-1，则 h= log<sub>2</sub>(n +1) (此时，判定树为深度=h的满二又树)，且表中每个记录的查找概率相等: p<sub>i</sub>=1/n。则：  
$$ASL=\frac{n+1}{n}log_2(n-1)-1$$
**特点**：  
+ 优点: 效率比顺序查找高折半查找
+ 缺点: 只适用于有序表且限子顺序存储结构 (对线性链表无效）
## 分块查找（索引顺序查找）
**条件**：
+ 1、将表分成几块，且表有序，或者分块有序；若i<j，则第j块中所有记录的关键字均大于第i块中的最大关键字
+ 2、建立“索引表” (每个结点含有最大关键字域和指向本块第一个结点的指针，且按关键字有序)

**查找过程**:  
先确定待查记录所在块(顺序或折半查找)再在块内查找(顺序查找)

:point_right: ASL=L<sub>b</sub>+L<sub>w</sub>：
    + L<sub>b</sub>：对索引表查找的ASL
    + L<sub>w</sub>： 对块内查找的ASL
$$ASL_{bs}=log_2(\frac{n}{s}+1)+\frac{s}{2} \quad(log_2n\leq ASL_{bs}\leq \frac{n+1}{2})$$

**特点**：  
+ 优点: 插入和删除比较容易，无需进行大量移动
+ 缺点: 需要增加一个索引表的储存空间并对初始索引表进行排序运算
+ 适用情况：如果线性表既要快速查找又经常动态变化，则可采用分块查找

## 查找方法比较

||顺序查找|折半查找|分块查找|
|---|---|---|---|
|ASL|最大|最小|中间|
|表结构|有序表、无需表|有序表|分块有序|
|存储结构|顺序表、线性链表|顺序表|顺序表、线性链表|

# 树表的查找
:raising_hand: 当表插入、删除操作频繁时，为维护表的有序性，需要移动表中很多记录。  
:teacher: 改用动态查找表——几种特殊的树
树：
+ 表结构在查找过程中动态生成
+ 对于给定值key若表中存在，则成功返回;
+ 否则，插入关键字等于key 的记录

**几种特殊的树**：
1. **二叉排序树**
2. **平衡二叉树**
3. 红黑树
4. B-树
5. B+树
6. 键树

## 二叉排序树（Binary Sort Tree) 又称为二叉搜索树、二又查找树

    定义：二叉排序树或是空树，或是满足如下性质的二叉树
    (1)若其左子树非空，则左子树上所有结点的值均小于根结点的值
    (2)若其右子树非空，则右子树上所有结点的值均大于等于根结点的值
    (3)其左右子树本身又各是一棵二又排序树

例：
![二叉排序树示例](github图片/7-2.png)

:point_right: 中序遍历二叉排序树，结果有什么规律？  
**二叉排序树性质**：  
中序遍历非空的二又排序树所得到的数据元素序列是一个按关键字排列的**递增有序序列**

**算法步骤**：
1. 若二又排序树为空，则查找失败，返向空指针
1. 若查找的关键字等于根结点，成功
2. 否则:
   - 若小于根结点，查其左子树
   - 若大于根结点，查其右子树
3. 在左右子树上的操作类似

```
struct TreeNode {
    int data;
    TreeNode* left;
    TreeNode* right;

    TreeNode(int value) : data(value), left(nullptr), right(nullptr) {}
};

// 递归查找函数
TreeNode* searchBST(TreeNode* root, int target) {
    // 如果树为空或者找到目标值，返回当前节点
    if (root == nullptr || root->data == target) {
        return root;
    }

    // 如果目标值小于当前节点值，在左子树中继续查找
    if (target < root->data) {
        return searchBST(root->left, target);
    }
    // 如果目标值大于当前节点值，在右子树中继续查找
    else {
        return searchBST(root->right, target);
    }
}
```

:point_right: 二又排序树上查找某关键字等于给定值的结点过程，其实就是走了一条从根到该结点的路径

:point_right: 比较的关键字次数=此结点所在层次数  

:point_right: 最多的比较次数=树的深度 

:disguised_face: 含有 n 个结点的二又排序树的平均查找长度和树的形态有关  
最好情况:
+ 初始序列45,24,53,12,37,93}
+ $ASL=log_2(n + 1)-1$;
+ 树的深度为: $\lfloor log_2n\rfloor+ 1$
+ 与折半查找中的判定树相同(形态比较均):  O(log<sub>2</sub>n)

最坏情况:
+ 初始序列12,24,37,45,53,93
+ 插入的n个元素从一开始就有序变成单支树的形态!
+ 此时树的深度为 n,ASL =(n + 1)/2
+ 查找效率与顺序查找情况相同: O(n)

:raising_hand: 如何提高形态不均衡的二叉排序树的查找效率?  
:teacher: 做“**平衡化**”处理，即尽量让二又树的形状均衡!

### 二叉排序树的操作——插入
1. 若二又排序树为空，则插入结点作为根结点插入到空树中
2. 否则，继续在其左、右子树上查找
    + 树中已有，不再插入
    + 树中没有
        - 查找直至某个叶子结点的左子树或右子树为空为止，则插入结点应为该叶子结点的左孩子或右孩子

```
TreeNode* insertBST(TreeNode* root, int value) {
    // 如果树为空，直接插入新节点
    if (root == nullptr) {
        return new TreeNode(value);
    }

    // 如果插入值小于当前节点值，在左子树中插入
    if (value < root->data) {
        root->left = insertBST(root->left, value);
    }
    // 如果插入值大于当前节点值，在右子树中插入
    else if (value > root->data) {
        root->right = insertBST(root->right, value);
    }

    // 如果插入值等于当前节点值，不进行重复插入

    return root;
}
```

### 二叉排序树的操作——生成
    从空树出发，经过一系列的查找、插入操作后，可以生成一颗二叉排序树
:point_right: 一个无序序列可通过构造二叉排序树而变成一个有序序列构造树的过程就是对无序序列进行排序的过程。  
:point_right: 插入的结点均为叶子结点，故无需移动其他结点。相当于在有序序列上插入记录而无需移动其他记录
:point_right: 但是,关键字的输入顺序不同，建立的不同二叉排序树
```
// 从数组构建二叉排序树
TreeNode* buildBSTFromArr(const int arr[], int n) {
    TreeNode* root = nullptr;

    for (int i = 0; i < n; ++i) {
        root = insertBST(root, arr[i]);
    }

    return root;
}
```

### 二叉排序树的操作——删除
:nerd_face: 从二又排序树中删除一个结点，不能把以该结点为根的子树都删去只能删掉该结点，并且**还应保证删除后所得的二叉树仍然满足二叉排序树的性质不变**

由于中序遍历二又排序树可以得到一个递增有序的序列。那么，在二又排序树中删去一个结点相当于删去有序序列中的一个结点

:point_right: 将因删除结点而断开的二又链表重新链接起来；防止重新链接后树的高度增加.

1. 被删除的结点是叶子结点：直接删除
2. 被删除的结点只有左子树或者只有右子树，用其左子树或者右子树替换它 (结点替换) 。其双亲结点的相应指针域的值改为 “指向被删除结点的左子树或右子树
3. 被删除的结点既有左子树，也有右子树
   + 以其中序前趋值替换之 (值替换) ，然后再删除该前趋结点前趋是左子树中最大的结点。
   + 也可以用其后继替换之，然后再删除该后继结点。后继是右子树中最小的结点
  
  ```
  // 查找二叉排序树中最小值节点
TreeNode* findMin(TreeNode* node) {
    while (node->left != nullptr) {
        node = node->left;
    }
    return node;
}

// 递归删除函数
TreeNode* deleteNode(TreeNode* root, int key) {
    if (root == nullptr) {
        return root;
    }

    // 如果要删除的节点在左子树
    if (key < root->data) {
        root->left = deleteNode(root->left, key);
    }
    // 如果要删除的节点在右子树
    else if (key > root->data) {
        root->right = deleteNode(root->right, key);
    }
    // 如果找到要删除的节点
    else {
        // 节点只有一个子树或无子树
        if (root->left == nullptr) {
            TreeNode* temp = root->right;
            delete root;
            return temp;
        } else if (root->right == nullptr) {
            TreeNode* temp = root->left;
            delete root;
            return temp;
        }

        // 节点有两个子树，找到中序遍历的后继节点
        TreeNode* temp = findMin(root->right);

        // 将后继节点的值复制给当前节点
        root->data = temp->data;

        // 删除后继节点
        root->right = deleteNode(root->right, temp->data);
    }

    return root;
}
  ```


## 平衡二叉树
**平衡二叉树 (balanced binary tree)**
+ 又称AVL树(Adelson-Velskii and Landis)。
+ 一棵平衡二又树或者是空树，或者是具有下列性质的
  - 左子树与右子树的高度之差的绝对值小于等于1；
  - 左子树和右子树也是平衡二又排序树

:point_right: 为了方便起见，给每个结点附加一个数字，给出该结点左子树-右子树的高度差。这个数字称为结点的平衡因子 (BF)
$$平衡因子 = 结点左子树的高度 - 结点右子树的高度$$
根据平衡二叉树的定义，平衡二又树上所有结点的平衡因子只能是
-1、0，或1。

:point_right: 对于一棵有n个结点的$AVL$树，其高度保持在$`O(log_2n)`$数量级，ASL也保持在$`O(log_2n)`$量级

**平衡调整的四种类型:**
1. LL型
2. LR型
3. RL型
4. RR型

:point_right: 调整原则: 
1) 降低高度 
1) 保持二又排序树性质

## LL型调整
![image](github图片/7-3.png)
+ B结点带左子树α一起上升
+ A结点成为B的右孩子
+ 原来B结点的右子树β作为A的左子树

![image](github图片/7-4.png)

## RR型调整
![image](github图片/7-5.png)
+ B结点带右子树β一起上升
+ A结点成为B的左孩子
+ 原来B结点的左子树α作为A的右子树

![image](github图片/7-6.png)

## LR型
![image](github图片/7-7.png)

+ C结点穿过A、B结点上升
+ B结点成为C的左孩子，A结点成为C的右孩子
+ 原来C结点的左子树β作为B的右子树；原来C结点的右子树γ作为A的左子树

## RL型
![image](github图片/7-8.png)
+ c穿过AB结点上升(B>C>A)
+ A结点成为C的左子树，C的左子树β成为A的右子树（C>β>A）
+ B结点称为C的右子树，C的右子树γ成为B的左子树(B>γ>C)


# 散列表的查找
    基本思想：记录的存储位置与关键字之间存在对应关系
        对应关系——hash函数

**散列方法(杂凑法)**:  
选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放;查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比，确定查找是否成功。

**散列函数(杂凑函数)**:散列方法中使用的转换函数

**散列表**： 按照上述思想构建的表

**冲突**： 不同的关键码映射到同一散列地址

**同义词**： 具有相同函数值的多个关键字

:point_right: 使用散列表要解决好两个问题
+ 1)构造好的散列函数
    - (a)所选函数尽可能简单，以便提高转换速度
    - (b)所选函数对关键码计算出的地址，应在散列地址集中致均匀分布，以减少空间浪费。
+ 2)制定一个好的解决冲突的方案
  - 查找时，如果从散列函数计算出的地址中查不到关键码，则应当依据解决冲突的规则，有规律地查询其它相关单元


:point_right: 构造散列函数考虑的因素
+ 执行速度（即计算散列函数所需时间）
+ 关键字长度
+ 散列表的大小
+ 关键字的分布形况
+ 查找频率

:point_right: 构造散列函数的要求
+ 要求一: n个数据原仅占用n个地址虽然散列查找是以空间换时间，但仍希望散列的**地址空间尽量小**
+ 要求二:无论用什么方法存储，目的都是尽量**均匀**地存放元素，以避免冲突。

:point_right: 构造散列函数的方法
+ 直接定址法
+ 数字分析法
+ 平方取中法
+ 折叠法
+ **除留余数法**
+ 随机数法

**查找过程**：  
![image](github图片/7-9.png)

## 直接定址法
$$Hash(key)=A·key+b(a、b为常数)$$

**优点**: 以关键码key的某个线性函数值为散列地址，不会产生冲突
**缺点**:要占用连续地址空闯，空询效率低

## 除留余数法
$$Hash(key)=key mod p(p是一个整数)$$

**关键**：如何选取合适的p

**技巧**: 设表长为m，取 p≤m 且为质数

# 处理冲突的方法
+ 开放定址法 (开地址法)
+ 链地址法 (拉链法)
+ 再散列法 (双散列函数法
+ 建立一个公共溢出区

## 开放定址法 (开地址法)
基本思想:有冲突时就去寻找**下一个**空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入

**常用方法**：
+ 线性探测法
+ 二次探测法
+ 伪随机探测法

### 线性探测法
$$H_i=(Hash(key)+d_i)\text{ mod m}(1≤i≤m)$$

### 二次探测法
$$H_i=(Hash(key)+d_i)\text{ mod m}(1≤i≤m)$$
其中:   
m为散列表长度，m要求是某个4k+3的质数  
d<sub>i</sub>为增量序列
$$1^2，-1^2，2^2，-2^2，...，q^2$$

### 伪随机探测法
$$H_i=(Hash(key)+d_i)\text{ mod m}(1≤i≤m)$$

其中： m为散列表长度  
d<sub>i</sub>为伪随机数

## 链地址法 (拉链法)
    基本思想：相同散列地址的记录链成一单链表

m个散列地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。

建立步骤： 
+ Step1:取数据元素的头键字key计算其散列函数值 (地址)。若该地址对应的链表为空，则将该元素插入此链表，否则执行Step2解决冲突。
+ Step2:根据选择的冲突处理方法，计算关键字kev的下个存储地址若该地址对应的链表为不为空，则利用链表的前插法或后插法将该元素插入此链表

优点：
+ 非同义词不会冲突，无聚集现象
+ 链表上的空间动态申请，更适合于表长不确定的情况


