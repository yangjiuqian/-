# 查找的概念
:raising_hand: 在哪里找？   
                     ——查找表

查找表是由同一类型的数据元素 (或记录) 构成的集合。由于“集合”中的数据元素之间存在着松散的关系，因此查找表是一种应用灵便的结构

:raising_hand: 什么查找？——
根据给定的某个值，在查找表中确定一个其关键字等于给定值
的数据元素或(记录)  
**关键字**：用来标识一个数据元素 (或记录)的某个数据项的值
+ **主关键字**：可唯一地标识一个记录的关键字是主关键字
+ **次关键字**：反之，用以识别若千记录的关键字是次关键字。

:raising_hand: 查找成功否？
+ 若查找表中存在这样一个记录，则称“查找成功”查找结果给出整个记录的信息，或指示该记录在查找表中的位置、
+ 否则称“查找不成功”，查找结果给出“空记录”或“空指针”

:raising_hand: 查找的目的？
1. 查询某个“特定的”数据元素是否在查找表中
2. 检索某个“特定的”数据元素的各种属性
3. 在查找表中插入一个数据元素
4. 删除查找表中的某个数据元素

:raising_hand: 查找表怎么分类？
+ 静态查找表
  - 仅作“查询”（检索）操作的查找表
+ 动态查找表
  - 作“插入”和“删除”操作的查找表作
  - 有时在查询之后，还需要将“查询”结果为“不在查找表中”的数据元素插入到查找表中;
  - 或者，从查找表中删除其“查询”结果为在查找表中”的数据元素，此类表为动态查找表

:raising_hand: 如何评价查找算法？

关键字的平均比较次数，也称**平均查找长度**ASL(AVerage Search Length)
$$ASL=\displaystyle\sum_{i=1}^{n} p_ic_i   （关键字比较次数的期望值）$$

+ n：记录的个数
+ p<sub>i</sub>:查找第i个记录的概率（通常认为p<sub>i</sub>=1/n）  
+ c<sub>i</sub>：找到第i个记录所需的比较次数
  
:raising_hand: 如何评价查找算法？

查找的方法取决于查找表的结构，即表中数据元素是依何种关系组织在一起的。
由于对查找表来说，在集合中查询或检索一个“特定的”数据元素时若无规律可循，只能对集合中的元素一一加以辨认直至找到为止。
而这样的“查询”或“检索”是任何计算机应用系统中使用频度都很高的操作，因此设法提高查找表的查找效率，是本章讨论问题的出发点
为提高查找效率一个办法就是在构造查找表时，在集合中的数据元素之间人为地加上某种确定的约束关系
研究查找表的各种组织方法及其查找过程的实施
# 线性表的查找
## 顺序查找
应用范围
+ 顺序表或线性链表表示的静态查找表
+ 表内元素之间无序

时间复杂度：O(n)  
空间复杂度：O（1）  
ASL(n)=（n+1）/2  

:point_right: 1、记录的查找概率不相等时如何提高查找效率?
+ 查找表存储记录原则一按查找概率高低存储
+ 1)查找概率越高，比较次数越少
+ 2)查找概率越低，比较次数较多

:point_right: 记录的查找概率无法测定时如何提高查找效率?
+ 方法按查找概率动态调整记录顺序
+ 1)在每个记录中设一不访问频度域
+ 2)始终保持记录按非递增有序的次序排列
+ 3)每次查找后均将刚查到的记录直接移至表头
  
**特点**：  
+ 优点: 算法简单，逻辑次序无要求，且不同存储结构均适用。
+ 缺点: ASL太长，时间效率太低
## 二分查找（折半查找，对分查找）
**有序表**

折半查找: 每次将待查记录所在区间缩小一半
+ 设表长为n，low、high和mid分别指向待查元素所在区间的上界下界和中点，key为给定的要查找的值:
+ 初始时，令low=1，high=n，mid=L(low+high)/2
+ 让k与mid指向的记录比较
    - 若keY==R[mid].key， 查找成功
    - 若key<R[mid].key，则 high=mid-1
    - 若key>R[mid].key，则 low=mid+1
+ 重复上述操作，直至low>high时查找失败

```#include <iostream>
#include <vector>

// 二分查找函数
int binarySearch(const std::vector<int>& arr, int target) {
    int left = 0;
    int right = arr.size() - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        // 检查中间元素是否是目标值
        if (arr[mid] == target) {
            return mid;  // 目标值找到，返回索引
        } else if (arr[mid] < target) {
            left = mid + 1;  // 目标值可能在右半部分
        } else {
            right = mid - 1;  // 目标值可能在左半部分
        }
    }

    return -1;  // 目标值不在数组中
}

int main() {
    // 测试二分查找
    std::vector<int> sortedArray = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int target = 6;

    int result = binarySearch(sortedArray, target);

    if (result != -1) {
        std::cout << "目标值 " << target << " 在数组中，索引为 " << result << std::endl;
    } else {
        std::cout << "目标值 " << target << " 不在数组中" << std::endl;
    }

    return 0;
}
```
## 
