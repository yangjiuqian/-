# 串
**定义**：零个或多个任意字符组成的有限序列；
  + **字串**：串中任意个连续字符组成的子序列（含空串）称为改串的子串；
  + **主串**：包含子串的串相应的称为主串；
  + **字符位置**：字符在序列中的序号为该字符在串中的位置；
  + **子串位置**：子串第一个字符在主串中的位置；
  + **空格串**：由一个或多个空格组成的串，与空串不同；
  + **串相等**：当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是相等的。**所有的空串都是相等的**。
## 案例
![image](https://github.com/yangjiuqian/DataStructure/assets/112688628/e3ebc308-7997-41b3-a85b-89f2ecfb7269)
## 串的类型定义、存储结构及运算
**串的顺序存储结构**：
```
typedef struct{
    char ch[MAXSIZE];
    int length;
}SString;
```

**串的链式存储结构**：
![image](https://github.com/yangjiuqian/DataStructure/assets/112688628/f4c19b2b-c21e-4e18-9c5f-b80b020206b4)
```
typedef struct{
    char ch[CHUNKSIZE];
    struct Chunk *next;
}Chunk;

typedef struct{
    Chunk *head,*tail;
    int curlen;
}LString;
```
## 串的模式匹配：
**定义**：确定主串中所含子串（模式串）第一次出现的位置（定位）。
  + **BF算法**（Brute-Force，又称古典的、经典的、朴素的、穷举的）;
      - **可直接运行**：
```
int Index_BF(string A,string B){
    int i=0,j=0,index=0;
    while(i<A.length() && j<B.length()){//while循环里的条件：只能匹配到length-1的位置，因为是从0开始匹配的
        if(A[i]==B[j]){
            ++i;
            ++j；//主串和子串依次匹配下一个字符
        }
        else{
            i=i-j+1;
            j=0;//主串、子串指针回溯重新开始下一次匹配
        }
    }
    if(j>=B.length()){
        return i-B.length();//返回匹配成功的第一个字符的下标
    }
    else{
        return -1;//模式匹配不成功。
    }
}
```
  + **KMP算法**（速度快）。
