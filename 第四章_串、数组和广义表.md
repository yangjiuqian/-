# 串
**定义**：零个或多个任意字符组成的有限序列；
  + **字串**：串中任意个连续字符组成的子序列（含空串）称为改串的子串；
  + **主串**：包含子串的串相应的称为主串；
  + **字符位置**：字符在序列中的序号为该字符在串中的位置；
  + **子串位置**：子串第一个字符在主串中的位置；
  + **空格串**：由一个或多个空格组成的串，与空串不同；
  + **串相等**：当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是相等的。**所有的空串都是相等的**。
## 案例
![image](https://github.com/yangjiuqian/DataStructure/assets/112688628/e3ebc308-7997-41b3-a85b-89f2ecfb7269)
## 串的类型定义、存储结构及运算
**串的顺序存储结构**：
```
typedef struct{
    char ch[MAXSIZE];
    int length;
}SString;
```

**串的链式存储结构**：
![image](https://github.com/yangjiuqian/DataStructure/assets/112688628/f4c19b2b-c21e-4e18-9c5f-b80b020206b4)
```
typedef struct{
    char ch[CHUNKSIZE];
    struct Chunk *next;
}Chunk;

typedef struct{
    Chunk *head,*tail;
    int curlen;
}LString;
```
## 串的模式匹配：
**定义**：确定主串中所含子串（模式串）第一次出现的位置（定位）。
  + **BF算法**（Brute-Force，又称古典的、经典的、朴素的、穷举的）;
      - **可直接运行**：
```
int Index_BF(string A,string B){
    int i=0,j=0,index=0;
    while(i<A.length() && j<B.length()){//while循环里的条件：只能匹配到length-1的位置，因为是从0开始匹配的
        if(A[i]==B[j]){
            ++i;
            ++j；//主串和子串依次匹配下一个字符
        }
        else{
            i=i-j+1;
            j=0;//主串、子串指针回溯重新开始下一次匹配
        }
    }
    if(j>=B.length()){
        return i-B.length();//返回匹配成功的第一个字符的下标
    }
    else{
        return -1;//模式匹配不成功。
    }
}
```
**//算法解释：实际代码运算是从0开始计数，所以回溯的步骤上“i=i-j+1”此时的下表“j”正好表示前进了的次数，将“j”减去再加1完成回溯。**
**//数组从o开始计数，所以每个元素的下标刚好可以用来表示前进了的步数，回溯时减去下标再加1即可完成回溯。**
  + **KMP算法**（速度快）。
```
#include <iostream>
#include <vector>

// 计算部分匹配表（Partial Match Table）
std::vector<int> computeLPS(const std::string& pattern) {
    int m = pattern.size();
    std::vector<int> lps(m, 0);
    int len = 0;  // 当前匹配的前缀长度

    for (int i = 1; i < m; ) {
        if (pattern[i] == pattern[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                // 回溯到上一个匹配前缀的末尾
                len = lps[len - 1];
            } else {
                // 没有匹配的前缀，继续下一个字符
                lps[i] = 0;
                i++;
            }
        }
    }

    return lps;
}

// KMP算法
std::vector<int> KMP(const std::string& text, const std::string& pattern) {
    std::vector<int> result;
    int n = text.size();
    int m = pattern.size();
    std::vector<int> lps = computeLPS(pattern);

    int i = 0;  // 文本指针
    int j = 0;  // 模式指针

    while (i < n) {
        if (pattern[j] == text[i]) {
            j++;
            i++;
        }

        if (j == m) {
            // 找到匹配，将匹配的起始位置保存
            result.push_back(i - j);
            j = lps[j - 1];
        } else if (i < n && pattern[j] != text[i]) {
            if (j != 0) {
                // 不匹配时，回溯到上一个匹配前缀的末尾
                j = lps[j - 1];
            } else {
                // 没有匹配的前缀，继续下一个字符
                i++;
            }
        }
    }

    return result;
}

int main() {
    std::string text = "ABABDABACDABABCABAB";
    std::string pattern = "ABABCABAB";

    std::vector<int> result = KMP(text, pattern);

    if (result.empty()) {
        std::cout << "Pattern not found in the text." << std::endl;
    } else {
        std::cout << "Pattern found at positions: ";
        for (int pos : result) {
            std::cout << pos << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}
```

